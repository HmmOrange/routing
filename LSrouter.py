####################################################
# LSrouter.py
# Name:
# HUID:
#####################################################

from router import Router
from packet import Packet
import heapq
import json

class LSrouter(Router):
    """Link state routing protocol implementation.

    Add your own class fields and initialization code (e.g. to create forwarding table
    data structures). See the `Router` base class for docstrings of the methods to
    override.
    """

    def __init__(self, addr, heartbeat_time):
        Router.__init__(self, addr)  # Initialize base class - DO NOT REMOVE
        self.heartbeat_time = heartbeat_time
        self.last_time = 0

        # TODO
        #   add your own class fields and initialization code here

        
        # Link State Database, lưu trữ Sequence Number + Link State của mỗi router
        # {router_addr: (seq_num, link_state)}
        self.link_state_db = {}

        # Xây dựng Link State cho router hiện tại, lưu trữ cổng được dùng -> địa chỉ kề & trọng số
        # {port: (endpoint, cost)}
        self.link_state = {}

        # Bảng định tuyển
        # {dest_addr: out_port}
        self.forwarding_table = {}

        # Sequence Number cho cổng hiện tại, chỉ định thứ tự cập nhật Link State
        self.seq_num = 0

    def handle_packet(self, port, packet):
        """Process incoming packet."""
        # TODO
        if packet.is_traceroute:
            # Hint: this is a normal data packet
            # If the forwarding table contains packet.dst_addr
            #   send packet based on forwarding table, e.g., self.send(port, packet)

            # Lấy địa chỉ đích của gói tin
            dest_addr = packet.dst_addr

            # Lấy cổng tiếp theo để gói tin có đi được đến dest_addr, sử dụng bảng định tuyến
            if dest_addr in self.forwarding_table:
                out_port = self.forwarding_table[dest_addr]

                # Gửi gói tin đến cổng định tuyến
                self.send(out_port, packet)
        else:
            # Hint: this is a routing packet generated by your routing protocol
            # If the sequence number is higher and the received link state is different
            #   update the local copy of the link state
            #   update the forwarding table
            #   broadcast the packet to other neighbors

            # Đọc thông tin gói tin

            content = json.loads(packet.content)
            src_addr = content["src_addr"]
            seq_num = content["seq_num"]
            link_state = content["link_state"]

            # Bỏ qua các cập nhật cũ hoặc lặp lại
            if src_addr in self.link_state_db and self.link_state_db[src_addr][0] >= seq_num:
                return
            
            # Cập nhật Link State Database và Bảng định tuyến bằng thuật toán Dijkstra
            self.link_state_db[src_addr] = (seq_num, link_state)
            self.dijkstra()
                

    def handle_new_link(self, port, endpoint, cost):
        """Handle new link."""
        # TODO
        #   update local data structures and forwarding table
        #   broadcast the new link state of this router to all neighbors

        self.link_state[port] = (endpoint, cost)
        self.seq_num += 1

        # Cập nhật bảng định tuyến
        self.dijkstra()

        # Cập nhật Link State của router hiện tại cho các router khác
        self.boardcast()

    def handle_remove_link(self, port):
        """Handle removed link."""
        # TODO
        #   update local data structures and forwarding table
        #   broadcast the new link state of this router to all neighbors

        if port in self.link_state:
            del self.link_state[port]
            self.sequence_number += 1

            # Cập nhật bảng định tuyến
            self.dijkstra()

            # Cập nhật Link State của router hiện tại cho các router khác
            self.boardcast()

    def handle_time(self, time_ms):
        """Handle current time."""
        if time_ms - self.last_time >= self.heartbeat_time:
            self.last_time = time_ms
            # TODO
            #   broadcast the link state of this router to all neighbors

            self.boardcast()

    def dijkstra(self):
        """Thuật toán Dijkstra để tìm đường đi ngắn nhất & cập nhật bảng định tuyến."""

        # Xây dựng đồ thị
        graph = {router_addr: link_state for router_addr, (seq_num, link_state) in self.link_state_db.items()}

        # Khoảng cách từ router hiện tại đến các router khác
        dist = {self.addr: 0}

        # Truy vết đồ thị
        trace = {}

        # Heap theo độ ưu tiên cost từ bé đến lớn
        heap = [(0, self.addr)]

        # Thuật toán Dijkstra, độ phức tạp O((M + N) log M):
        while heap:
            du, u = heapq.heappop(heap)

            if du != dist[u]:
                continue

            for port, (v, cost) in graph.get(u, {}).items():
                if v not in dist or dist[v] > dist[u] + cost:
                    dist[v] = dist[u] + cost
                    trace[v] = u
                    heapq.heappush(heap, (dist[v], v))

        # Xây dựng lại bảng định tuyến
        self.forwarding_table.clear()
        for v in dist:
            if v == self.addr:
                continue

            next_hop = v
            while trace[next_hop] != self.addr:
                next_hop = trace[next_hop]

            # Tìm cổng đã kết nối với next_hop
            for port, (endpoint, _) in self.link_state.items():
                if endpoint == next_hop:
                    self.forwarding_table[v] = port
                    break

    def boardcast(self):
        """Cập nhật Link State của router hiện tại cho các router khác (Link State Advertisement)."""
        lsa = {
            'src_addr': self.addr,
            'seq_num': self.seq_num,
            'link_state': self.link_state
        }

        self.link_state_db[self.addr] = (self.seq_num, self.link_state)
        content = json.dumps(lsa)
        packet = Packet(Packet.ROUTING, self.addr, None, content)

        for port in self.link_state:
            self.send(port, packet)
            
    def __repr__(self):

        """Representation for debugging in the network visualizer."""
        # TODO
        #   NOTE This method is for your own convenience and will not be graded
        return f"LSrouter(addr={self.addr})"
