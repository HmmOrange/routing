####################################################
# DVrouter.py
# Name:
# HUID:
#####################################################

import json
from packet import Packet
from router import Router


class DVrouter(Router):
    """Distance vector routing protocol implementation.

    Add your own class fields and initialization code (e.g. to create forwarding table
    data structures). See the `Router` base class for docstrings of the methods to
    override.
    """

    def __init__(self, addr, heartbeat_time):
        Router.__init__(self, addr)  # Initialize base class - DO NOT REMOVE
        self.heartbeat_time = heartbeat_time
        self.last_time = 0
        # TODO
        #   add your own class fields and initialization code here

        # Xây dựng đỉnh kề cho router hiện tại, lưu trữ cổng được dùng -> địa chỉ kề & trọng số
        # {port: (neighbor, cost)}
        self.neighbors = {}

        # Bảng định tuyển
        # {dest_addr: out_port}
        self.forwarding_table = {}

        # Distance Vector
        # {addr: (port, cost)}
        self.distance_vector = {self.addr : (None, 0)}
        self.INF = float('inf')

    def handle_packet(self, port, packet):
        """Process incoming packet."""
        # TODO
        if packet.is_traceroute:
            # Hint: this is a normal data packet
            # If the forwarding table contains packet.dst_addr
            #   send packet based on forwarding table, e.g., self.send(port, packet)
            dest_addr = packet.dst_addr

            # Lấy cổng tiếp theo để gói tin có đi được đến dest_addr, sử dụng bảng định tuyến
            if dest_addr in self.forwarding_table:
                out_port = self.forwarding_table[dest_addr]

                # Gửi gói tin đến cổng định tuyến
                self.send(out_port, packet)
        else:
            # Hint: this is a routing packet generated by your routing protocol
            # If the received distance vector is different
            #   update the local copy of the distance vector
            #   update the distance vector of this router
            #   update the forwarding table
            #   broadcast the distance vector of this router to neighbors
            
            content = json.loads(packet.content)
            distance_vector = content["distance_vector"]

            self.bellman_ford(port, distance_vector)


    def handle_new_link(self, port, endpoint, cost):
        """Handle new link."""
        # TODO
        #   update the distance vector of this router
        #   update the forwarding table
        #   broadcast the distance vector of this router to neighbors

        self.neighbors[port] = (endpoint, cost)
        self.distance_vector[endpoint] = (port, cost)
        self.forwarding_table[endpoint] = port

        # Cập nhật Distance Vector của router hiện tại cho các router khác
        self.broadcast()

    def handle_remove_link(self, port):
        """Handle removed link."""
        # TODO
        #   update the distance vector of this router
        #   update the forwarding table
        #   broadcast the distance vector of this router to neighbors

        if port not in self.neighbors:
            return

        del self.neighbors[port]

        # Hủy bỏ tất cả đường đi qua cổng
        removed = []
        for dest, (p, _) in self.distance_vector.items():
            if p == port:
                removed.append(dest)

        for dest in removed:
            del self.distance_vector[dest]
            if dest in self.forwarding_table:
                del self.forwarding_table[dest]

        # Cập nhật Distance Vector của router hiện tại cho các router khác
        self.broadcast()

    def handle_time(self, time_ms):
        """Handle current time."""
        if time_ms - self.last_time >= self.heartbeat_time:
            self.last_time = time_ms
            # TODO
            #   broadcast the distance vector of this router to neighbors

            self.broadcast()
            pass

    def bellman_ford(self, port, distance_vector):
        """Thuật toán Bellman-Ford để tìm đường đi ngắn nhất & cập nhật bảng định tuyến."""
        if port not in self.neighbors:
            return
        
        # u: router hiện tại, port: gửi vector
        _, du_port = self.neighbors[port]

        updated = False
        for v, dport_v in distance_vector.items():
            if v == self.addr:
                continue
            
            # d_{u -> v} = min(d_{u -> port} + d_{port -> v})
            if v not in self.distance_vector or du_port + dport_v < self.distance_vector[v][1]:
                self.distance_vector[v] = (port, du_port + dport_v)
                self.forwarding_table[v] = port
                updated = True
            else:
                if self.distance_vector[v][0] == port and dport_v == self.INF:
                    del self.distance_vector[v]
                    if v in self.forwarding_table:
                        del self.forwarding_table[v]
                    updated = True

        if updated:
            self.broadcast()

    def broadcast(self):
        for port, (neighbor, _) in self.neighbors.items():
            advertised_vector = {}
            for dest, (out_port, cost) in self.distance_vector.items():
                # Nếu ta đang dùng port -> dest, không gửi lại dest -> port trọng số bình thường để tránh vòng lặp vô hạn
                if out_port == port and dest != neighbor:
                    advertised_vector[dest] = self.INF
                else:
                    advertised_vector[dest] = cost
                    
            content = json.dumps({
                "distance_vector": advertised_vector
            })

            packet = Packet(Packet.ROUTING, self.addr, None, content)
            self.send(port, packet)

    def __repr__(self):
        """Representation for debugging in the network visualizer."""
        # TODO
        #   NOTE This method is for your own convenience and will not be graded
        return f"DVrouter(addr={self.addr})"
